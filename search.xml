<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java多态与向上向下转型]]></title>
    <url>%2F2018%2F05%2F19%2Fjava%E5%A4%9A%E6%80%81%E4%B8%8E%E5%90%91%E4%B8%8A%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[javase之多态与向上向下转型javase之多态定义：多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法。 那么多态如何实现呢，多态的实现技术是“动态绑定”，指的是在执行期间判断引用对象的实际类型，根据其实际的类型调用其相应的方法（这一点我们在后面的向上向下转型中会解释的很清楚） 多态的作用：消除类型之间的耦合关系。 多态的应用在生活中无处不在，同一件事发生在不同对象身上会产生不同的结果。就好如快捷键F1，在word中是Word帮助，在Window下就是window帮助和支持。 多态存在的三个必要条件：一.要有继承二.要有重写三.父类引用指向子类对象 java中动态的实现方式：接口实现继承父类方法重写同一个类中进行方法重载 注：java中动态绑定技术涉及到jvm，我不懂哈，有时间再去研究，这里就不说了。 向上转型和向下转型向上转型子类引用的对象转换为父类类型称为向上转型，通俗的说就是将子类对象转为父类对象。 网上看到的例子可以很清楚的解释向上转型，请看：123456789101112131415161718192021222324252627282930313233343536373839404142public class Animal &#123; public void eat()&#123; System.out.println("animal eatting..."); &#125;&#125;public class Cat extends Animal&#123; public void eat()&#123; System.out.println("我吃鱼"); &#125;&#125;public class Dog extends Animal&#123; public void eat()&#123; System.out.println("我吃骨头"); &#125; public void run()&#123; System.out.println("我会跑"); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Animal animal = new Cat(); //向上转型 animal.eat(); animal = new Dog(); animal.eat(); &#125;&#125;//结果://我吃鱼//我吃骨头 Animal animal = new Cat();将子类对象转化为父类对象Animal。这个时候animal这个引用调用的方法是子类方法。继承链中对象方法的调用的优先级：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。这个在后面会有详解。 转型中需要注意的问题1.向上转型时，子类单独定义的方法会丢失。比如上面Dog类中定义的run方法，当animal引用指向Dog类实例时是访问不到run方法的，animal.run（）;会报错。2.子类引用不能指向父类对象。Cat c = (Cat)new Animal();这样不行。 向上转型的好处1.减少重复代码，是代码变得简洁。2.提高系统扩展性那么举个例子：我现在有很多种类的动物，他们要吃东西。如果不用向上转型，那我应该这么写：12345678910111213public void eat(Cat c)&#123; c.eat();&#125;public void eat(Dog d)&#123; d.eat();&#125;//......eat(new Cat());eat(new Cat());eat(new Dog());//...... 一种动物就要写一个方法，如果我有一万种动物，我就要写一万个方法，写完我就要疯了。但是如果我用向上转型，我只需要这样写：12345678public void eat(Animal a)&#123; a.eat();&#125;eat(new Cat());eat(new Cat());eat(new Dog());//..... 是不是很简洁？而且这个时候，如果我又有一个动物加进来，我只需要实现它的类，让他继承Animal就好了，不需要为它单独写一个eat方法。 向下转型说完向上转型接下来就是向下转型了，向下转型是把父类对象转为子类对象。 还是上面那个例子：123456789101112//还是上面的animal和cat dogAnimal a = new Cat();Cat c = ((Cat) a);c.eat();//输出 我吃鱼Dog d = ((Dog) a);d.eat();// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Cat cannot be cast to com.chengfan.animal.DogAnimal a1 = new Animal();Cat c1 = ((Cat) a1);c1.eat();// 报错 ： java.lang.ClassCastException：com.chengfan.animal.Animal cannot be cast to com.chengfan.animal.Cat 为什么第一段不报错呢？因为a本来就是Cat对象，所以当然可以向下转型为Cat，也理所应当不能转为Dog。而a1为Animal对象（父类），它不能向下转型为任何子类对象。 向下转型注意事项1.向下转型的前提是父类引用指向子类对象（也就是说，在向下转型之前，它得先向上转型）2.向下转型只能转型为本类对象（猫怎么会变成狗呢，对吧）3.为了安全的类型转换，最好先用 if(A instanceof B) 判断一下下~~ 经典案例分析多态加个餐，看：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class A &#123; public String show(D obj) &#123; return ("A and D"); &#125; public String show(A obj) &#123; return ("A and A"); &#125;&#125;class B extends A&#123; public String show(B obj)&#123; return ("B and B"); &#125; public String show(A obj)&#123; return ("B and A"); &#125;&#125;class C extends B&#123;&#125;class D extends B&#123;&#125;public class Demo &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println("1--" + a1.show(b)); System.out.println("2--" + a1.show(c)); System.out.println("3--" + a1.show(d)); System.out.println("4--" + a2.show(b)); System.out.println("5--" + a2.show(c)); System.out.println("6--" + a2.show(d)); System.out.println("7--" + b.show(b)); System.out.println("8--" + b.show(c)); System.out.println("9--" + b.show(d)); &#125;&#125;//结果：//1--A and A//2--A and A//3--A and D//4--B and A//5--B and A//6--A and D//7--B and B//8--B and B//9--A and D//能看懂这个结果么？先自分析一下。 划重点咯：当父类对象引用变量引用子类对象时，被引用对象的类型决定了调用谁的成员方法，引用变量类型决定可调用的方法。如果子类中没有覆盖该方法，那么会去父类中寻找。运行时多态性是面向对象程序设计代码重用的一个最强大机制，动态性的概念也可以被说成“一个接口，多个方法”。Java实现运行时多态性的基础是动态方法调度，它是一种在运行时而不是在编译期调用重载方法的机制。方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。 我们来分析4：a2.show（b）首先，a2是类型为A的引用类型，它指向类型为B的对象。A确定可调用的方法：show(D obj)和show(A obj)。a2.show(b) ==&gt; this.show(b)，这里this指的是B。然后.在B类中找show（B obj），找到了，可惜没用，因为show（B obj）方法不在可调用范围内，this.show(O)失败，进入下一级别：super.show(O)，super指的是A。在A 中寻找show（B obj)，失败，因为没用定义这个方法。因此转到第三优先级this.show((super)O)，this仍然是a2，这里O为B，(super)O即(super)B即A，因此它到类A里面找show(A obj)的方法，类A有这个方法，但是由于a2引用的是类B的一个对象，B覆盖了A的show(A obj)方法，因此最终锁定到类B的show(A obj)，输出为”B and A”。 再比如分析8：b.show(c));b.show(c)，b是一个引用变量，类型为B，则this为b，c是C的一个实例，于是它到类B找show(C obj)方法，没有找到，转而到B的超类A里面找，A里面也没有，因此也转到第三优先级this.show((super)O)，this为b，O为C，(super)O即(super)C即B，因此它到B里面找show(B obj)方法，找到了，由于b引用的是类B的一个对象，因此直接锁定到类B的show(B obj)，输出为”B and B”。按照上面的方法，可以正确得到其他的结果。问题还要继续，现在我们再来看上面的分析过程是怎么体现出那句话的内涵的。它说：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。还是拿a2.show(b)来说吧。a2是一个引用变量，类型为A，它引用的是B的一个对象，因此这句话的意思是由B来决定调用的是哪个方法。因此应该调用B的show(B obj)从而输出”B and B”才对。但是为什么跟前面的分析得到的结果不相符呢？！问题在于我们不要忽略了后半部分，那里特别指明：这个被调用的方法必须是在超类中定义过的，也就是被子类覆盖的方法。B里面的show(B obj)在超类A中有定义吗？没有！那就更谈不上被覆盖了。实际上这句话隐藏了一条信息：它仍然是按照方法调用的优先级来确定的。它在类A中找到了show(A obj)，如果子类B没有覆盖show(A obj)方法，那么它就调用A的show(A obj)（由于B继承A，虽然没有覆盖这个方法，但从超类A那里继承了这个方法，从某种意义上说，还是由B确定调用的方法，只是方法是在A中实现而已）；现在子类B覆盖了show(A obj)，因此它最终锁定到B的show(A obj)。这就是那句话的意义所在。]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈java中对象类型引用是引用还是指针]]></title>
    <url>%2F2018%2F05%2F16%2F%E8%B0%88%E8%B0%88java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%83%8F%E6%98%AF%E5%BC%95%E7%94%A8%E8%BF%98%E6%98%AF%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[java中对象变量是不是指针？在java中，也存在指针，不过被称为被限制的指针。即其值是其他变量或内存块的地址，但不能使用指针的各种操作。 java的对象类型java中的对象类型只有一种，那就是引用。下面是定义一个引用的代码。 String s = new String(“string”); 上面的语句总其实做了两件事，在堆中创建了一个String对象，内容为”string”,在栈中创建了一个引用s，它指向堆中刚创好的String对象。并且引用s值的改变不影响它所指的对象。请看下面语句： s = new String(“abc”); 在上面这个语句中，只改变s的值，因此不会对内容为”string”对象造成影响（不考虑垃圾回收情况）。只不过是s指向堆中新对象而已，丛指针上来说，就是s的值改变了而已。 从上面来看，java的引用，只是表示一个内存位置，该位置就是存在一个对象的位置，而不是真实的对象变量。从指针角度来讲c/c++的指针与jav的引用不谋而合。他们都表示一个内存地址，都可以通过这个内存地址来操纵它所对应的对象。 java中的指针本文中一开始说到java中的指针（引用）是限制的指针，那么就会有运算符来访问对象，java中采用 . 运算符的方式提供。 总结：java中的引用可以认为就是指针，是一种限制的指针，不能参与运行和指向任意位置的内存，并且不用显示回收对象。]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javase之方法与属性]]></title>
    <url>%2F2018%2F05%2F09%2Fjavase%E4%B9%8B%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本次分享内容主要包括以下几点· 方法· 方法调用· 方法重载· 属性 方法· java的方法类似于其他语言的函数，方法是个“黑匣子”，是一段用来完成特定功能的代码块，并返回结果。· 方法间允许相互调用· 如果方法具有返回值，方法中必须使用关键字return返回该值，返回类型为该返回值的类型· 如果方法没有返回值，则返回类型为void注意：方法的设计原则—- 一个方法只做一件事 方法的调用方法的调用分两种：1.外部调用：即调用其他类对象的方法时，通过“对象名.方法名（参数列表）”调用 2.内部调用：在类的内部调用时，可以通过“方法名（参数列表）调用”。 方法的重载（Overloading）方法重载的定义：如果有两个方法的方法名相同，但参数不一致，那么可以说一个方法是另一个方法的重载。 需注意java重载方法必须满足条件–“两同三不同”：–同一个类，同一个方法名–不同：参数列表不同（类型，个数，顺序不同） · 方法的返回值类型可以不相同· 方法的修饰符可以不相同· main方法也可以被重载 方法重载的特征：1.在同一个类中定义 2.方法名相同 3.方法的参数列表不同（以上都提到了） 以下实例演示了如何重载MyClass类的info方法class MyClass { int height; MyClass() { System.out.println(“无参数构造函数”); height = 4; } MyClass(int i) { System.out.println(“房子高度为 “ + i + “ 米”); height = i; } void info() { System.out.println(“房子高度为 “ + height + “ 米”); } void info(String s) { System.out.println(s + “: 房子高度为 “ + height + “ 米”); }}public class MainClass { public static void main(String[] args) { MyClass t = new MyClass(3); t.info(); t.info(“重载方法”); //重载构造函数 new MyClass(); }}以上代码运行输出结果是：房子高度为 3 米房子高度为 3 米重载方法: 房子高度为 3 米无参数构造函数 属性属性的设置原则：属性不可分属性指事物具有的特性，例如，人的身高，体重等都是属性 属性可以分为类属性和实例属性两种： （1），定义属性的时候没有static修饰的就是实例属性，实例属性从该类的实例被创建起开始存在，直到系统完全销毁这个实例，实例变量的作用域与对应实例的生存范围相同。 在程序中访问实例属性语法：实例.实例属性 （2），定义属性的时候有static修饰的就是类属性，类属性从该类的准备阶段起开始存在，直到系统完全销毁这个类，类属性的作用域与这个类的生存范围相同。 在程序中访问类属性语法：类.类属性。虽然也可以通过实例来访问static类属性，但是为了程序的可读性和明确性不建议这么使用。 属性在没有赋初值时系统会自动帮我们做初始化： 整型数据初始化为0，布尔型数据初始化为 false，对象类型初始化为 null。 实例变量的作用域在本类中完全有效，当被其他的类调用的时候也可能有效。 属性的初始化和内存中的运行机制—-（未完待续…）]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2018%2F05%2F06%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Chasing my dream with wonderful sunshine is the happiest for me in a day！]]></content>
      <tags>
        <tag>first</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postName]]></title>
    <url>%2F2018%2F05%2F06%2FpostName%2F</url>
    <content type="text"><![CDATA[MM626399………….]]></content>
  </entry>
</search>
